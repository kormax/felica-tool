package com.kormax.felicatool.processor

import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.Modifier
import com.google.devtools.ksp.validate

class SealedEnumProcessor(private val codeGenerator: CodeGenerator, private val logger: KSPLogger) :
    SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols =
            resolver.getSymbolsWithAnnotation("com.kormax.felicatool.annotation.SealedEnum")

        val unprocessed = mutableListOf<KSAnnotated>()

        symbols.forEach { symbol ->
            if (!symbol.validate()) {
                unprocessed.add(symbol)
                return@forEach
            }

            if (symbol is KSClassDeclaration && Modifier.SEALED in symbol.modifiers) {
                processSealed(symbol, resolver)
            } else {
                logger.error("@SealedEnum can only be applied to sealed classes", symbol)
            }
        }

        return unprocessed
    }

    private fun processSealed(classDeclaration: KSClassDeclaration, resolver: Resolver) {
        val packageName = classDeclaration.packageName.asString()
        val className = classDeclaration.simpleName.asString()

        // Get the value property name from annotation
        val annotation =
            classDeclaration.annotations.find { it.shortName.asString() == "SealedEnum" }
        val valueProperty =
            annotation?.arguments?.find { it.name?.asString() == "valueProperty" }?.value as? String
                ?: "value"

        // Find all data object subclasses (excluding Unknown)
        val sealedSubclasses = classDeclaration.getSealedSubclasses().toList()
        val dataObjects =
            sealedSubclasses.filter { subclass ->
                subclass.classKind == ClassKind.OBJECT &&
                    Modifier.DATA in subclass.modifiers &&
                    subclass.simpleName.asString() != "Unknown"
            }

        // Find the Unknown data class if it exists
        val unknownClass =
            sealedSubclasses.find { subclass ->
                subclass.simpleName.asString() == "Unknown" &&
                    subclass.classKind == ClassKind.CLASS &&
                    Modifier.DATA in subclass.modifiers
            }

        // Check if companion object exists
        val hasCompanionObject =
            classDeclaration.declarations.any { declaration ->
                declaration is KSClassDeclaration && declaration.isCompanionObject
            }

        // Determine the type of the value property
        val valueType =
            classDeclaration
                .getDeclaredProperties()
                .find { it.simpleName.asString() == valueProperty }
                ?.type
                ?.resolve()
                ?.declaration
                ?.simpleName
                ?.asString() ?: "Int"

        val generatedFileName = "${className}Extensions"

        val file =
            codeGenerator.createNewFile(
                dependencies =
                    Dependencies(
                        aggregating = true,
                        *listOfNotNull(classDeclaration.containingFile).toTypedArray(),
                    ),
                packageName = packageName,
                fileName = generatedFileName,
            )

        val entriesCode =
            dataObjects.joinToString(",\n        ") { "${className}.${it.simpleName.asString()}" }

        val unknownFallback =
            if (unknownClass != null) {
                "${className}.Unknown(value)"
            } else {
                "throw IllegalArgumentException(\"Unknown value: \$value\")"
            }

        val code = buildString {
            appendLine("// Generated by SealedEnumProcessor. Do not edit manually.")
            appendLine("package $packageName")
            appendLine()
            appendLine("private val ${className.lowercase()}Entries: List<$className> = listOf(")
            appendLine("        $entriesCode")
            appendLine(")")
            appendLine()
            appendLine(
                "private val ${className.lowercase()}KnownByValue: Map<$valueType, $className> = ${className.lowercase()}Entries.associateBy { it.$valueProperty }"
            )
            appendLine()
            // entries property on companion object
            appendLine(
                "val ${className}.Companion.entries: List<$className> get() = ${className.lowercase()}Entries"
            )
            appendLine()
            // Extension function on companion object
            appendLine(
                "fun ${className}.Companion.fromValue(value: $valueType): $className = ${className.lowercase()}KnownByValue[value] ?: $unknownFallback"
            )
        }

        file.write(code.toByteArray())
        file.close()

        logger.info("Generated $generatedFileName for $className with ${dataObjects.size} entries")
    }
}
